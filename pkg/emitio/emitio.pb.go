// Code generated by protoc-gen-go. DO NOT EDIT.
// source: emitio.proto

package emitio

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// EmitHeader MUST be the first message sent on a new Emit RPC bi-directional
// link to identify the stream.
type EmitHeader struct {
	// name is a required non-alterable user-friendly value to identify the source
	// of the data. This is likely the name of the binary generating data, e.g. nginx.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// presence is an identifier for the stream that if set allows for resuming
	// the stream should the streamer need to restart. If left blank, the stream
	// will be considered finished when the stream closes.
	Presence             string   `protobuf:"bytes,2,opt,name=presence" json:"presence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmitHeader) Reset()         { *m = EmitHeader{} }
func (m *EmitHeader) String() string { return proto.CompactTextString(m) }
func (*EmitHeader) ProtoMessage()    {}
func (*EmitHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_emitio_65d291393ec10fad, []int{0}
}
func (m *EmitHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitHeader.Unmarshal(m, b)
}
func (m *EmitHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitHeader.Marshal(b, m, deterministic)
}
func (dst *EmitHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitHeader.Merge(dst, src)
}
func (m *EmitHeader) XXX_Size() int {
	return xxx_messageInfo_EmitHeader.Size(m)
}
func (m *EmitHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitHeader.DiscardUnknown(m)
}

var xxx_messageInfo_EmitHeader proto.InternalMessageInfo

func (m *EmitHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EmitHeader) GetPresence() string {
	if m != nil {
		return m.Presence
	}
	return ""
}

// EmitMeta may be sent at any time to alter the metadata associated with a stream.
type EmitMeta struct {
	// meta is arbitrary labels that may be mutated over time and are used in data
	// selection for defining a service.
	Meta                 map[string]string `protobuf:"bytes,1,rep,name=meta" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EmitMeta) Reset()         { *m = EmitMeta{} }
func (m *EmitMeta) String() string { return proto.CompactTextString(m) }
func (*EmitMeta) ProtoMessage()    {}
func (*EmitMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_emitio_65d291393ec10fad, []int{1}
}
func (m *EmitMeta) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitMeta.Unmarshal(m, b)
}
func (m *EmitMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitMeta.Marshal(b, m, deterministic)
}
func (dst *EmitMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitMeta.Merge(dst, src)
}
func (m *EmitMeta) XXX_Size() int {
	return xxx_messageInfo_EmitMeta.Size(m)
}
func (m *EmitMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitMeta.DiscardUnknown(m)
}

var xxx_messageInfo_EmitMeta proto.InternalMessageInfo

func (m *EmitMeta) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

// EmitBody is the raw data forming the stream. In the case of file tailing, this is a single
// line. The agent may reject large bodies.
type EmitBody struct {
	Body                 []byte   `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmitBody) Reset()         { *m = EmitBody{} }
func (m *EmitBody) String() string { return proto.CompactTextString(m) }
func (*EmitBody) ProtoMessage()    {}
func (*EmitBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_emitio_65d291393ec10fad, []int{2}
}
func (m *EmitBody) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitBody.Unmarshal(m, b)
}
func (m *EmitBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitBody.Marshal(b, m, deterministic)
}
func (dst *EmitBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitBody.Merge(dst, src)
}
func (m *EmitBody) XXX_Size() int {
	return xxx_messageInfo_EmitBody.Size(m)
}
func (m *EmitBody) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitBody.DiscardUnknown(m)
}

var xxx_messageInfo_EmitBody proto.InternalMessageInfo

func (m *EmitBody) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

// EmitInput enumerates the distinct messages that may be sent to the agent.
type EmitInput struct {
	// Types that are valid to be assigned to Inputs:
	//	*EmitInput_Header
	//	*EmitInput_Meta
	//	*EmitInput_Body
	Inputs               isEmitInput_Inputs `protobuf_oneof:"inputs"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EmitInput) Reset()         { *m = EmitInput{} }
func (m *EmitInput) String() string { return proto.CompactTextString(m) }
func (*EmitInput) ProtoMessage()    {}
func (*EmitInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_emitio_65d291393ec10fad, []int{3}
}
func (m *EmitInput) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitInput.Unmarshal(m, b)
}
func (m *EmitInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitInput.Marshal(b, m, deterministic)
}
func (dst *EmitInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitInput.Merge(dst, src)
}
func (m *EmitInput) XXX_Size() int {
	return xxx_messageInfo_EmitInput.Size(m)
}
func (m *EmitInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitInput.DiscardUnknown(m)
}

var xxx_messageInfo_EmitInput proto.InternalMessageInfo

type isEmitInput_Inputs interface {
	isEmitInput_Inputs()
}

type EmitInput_Header struct {
	Header *EmitHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type EmitInput_Meta struct {
	Meta *EmitMeta `protobuf:"bytes,2,opt,name=meta,oneof"`
}
type EmitInput_Body struct {
	Body *EmitBody `protobuf:"bytes,3,opt,name=body,oneof"`
}

func (*EmitInput_Header) isEmitInput_Inputs() {}
func (*EmitInput_Meta) isEmitInput_Inputs()   {}
func (*EmitInput_Body) isEmitInput_Inputs()   {}

func (m *EmitInput) GetInputs() isEmitInput_Inputs {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *EmitInput) GetHeader() *EmitHeader {
	if x, ok := m.GetInputs().(*EmitInput_Header); ok {
		return x.Header
	}
	return nil
}

func (m *EmitInput) GetMeta() *EmitMeta {
	if x, ok := m.GetInputs().(*EmitInput_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *EmitInput) GetBody() *EmitBody {
	if x, ok := m.GetInputs().(*EmitInput_Body); ok {
		return x.Body
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EmitInput) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EmitInput_OneofMarshaler, _EmitInput_OneofUnmarshaler, _EmitInput_OneofSizer, []interface{}{
		(*EmitInput_Header)(nil),
		(*EmitInput_Meta)(nil),
		(*EmitInput_Body)(nil),
	}
}

func _EmitInput_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EmitInput)
	// inputs
	switch x := m.Inputs.(type) {
	case *EmitInput_Header:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *EmitInput_Meta:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *EmitInput_Body:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Body); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EmitInput.Inputs has unexpected type %T", x)
	}
	return nil
}

func _EmitInput_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EmitInput)
	switch tag {
	case 1: // inputs.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EmitHeader)
		err := b.DecodeMessage(msg)
		m.Inputs = &EmitInput_Header{msg}
		return true, err
	case 2: // inputs.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EmitMeta)
		err := b.DecodeMessage(msg)
		m.Inputs = &EmitInput_Meta{msg}
		return true, err
	case 3: // inputs.body
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EmitBody)
		err := b.DecodeMessage(msg)
		m.Inputs = &EmitInput_Body{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EmitInput_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EmitInput)
	// inputs
	switch x := m.Inputs.(type) {
	case *EmitInput_Header:
		s := proto.Size(x.Header)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EmitInput_Meta:
		s := proto.Size(x.Meta)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EmitInput_Body:
		s := proto.Size(x.Body)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EmitOutput may be returned by the emitio agent throughout the life of the
// stream.
type EmitOutput struct {
	// Types that are valid to be assigned to Outputs:
	//	*EmitOutput_Trigger
	Outputs              isEmitOutput_Outputs `protobuf_oneof:"outputs"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *EmitOutput) Reset()         { *m = EmitOutput{} }
func (m *EmitOutput) String() string { return proto.CompactTextString(m) }
func (*EmitOutput) ProtoMessage()    {}
func (*EmitOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_emitio_65d291393ec10fad, []int{4}
}
func (m *EmitOutput) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitOutput.Unmarshal(m, b)
}
func (m *EmitOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitOutput.Marshal(b, m, deterministic)
}
func (dst *EmitOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitOutput.Merge(dst, src)
}
func (m *EmitOutput) XXX_Size() int {
	return xxx_messageInfo_EmitOutput.Size(m)
}
func (m *EmitOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EmitOutput proto.InternalMessageInfo

type isEmitOutput_Outputs interface {
	isEmitOutput_Outputs()
}

type EmitOutput_Trigger struct {
	Trigger *EmitTrigger `protobuf:"bytes,1,opt,name=trigger,oneof"`
}

func (*EmitOutput_Trigger) isEmitOutput_Outputs() {}

func (m *EmitOutput) GetOutputs() isEmitOutput_Outputs {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *EmitOutput) GetTrigger() *EmitTrigger {
	if x, ok := m.GetOutputs().(*EmitOutput_Trigger); ok {
		return x.Trigger
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EmitOutput) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EmitOutput_OneofMarshaler, _EmitOutput_OneofUnmarshaler, _EmitOutput_OneofSizer, []interface{}{
		(*EmitOutput_Trigger)(nil),
	}
}

func _EmitOutput_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EmitOutput)
	// outputs
	switch x := m.Outputs.(type) {
	case *EmitOutput_Trigger:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Trigger); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EmitOutput.Outputs has unexpected type %T", x)
	}
	return nil
}

func _EmitOutput_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EmitOutput)
	switch tag {
	case 1: // outputs.trigger
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EmitTrigger)
		err := b.DecodeMessage(msg)
		m.Outputs = &EmitOutput_Trigger{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EmitOutput_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EmitOutput)
	// outputs
	switch x := m.Outputs.(type) {
	case *EmitOutput_Trigger:
		s := proto.Size(x.Trigger)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EmitTrigger is a remote signal to cause the agent to take an action.
type EmitTrigger struct {
	// trigger is arbitrary bytes left undefined for interpretation and extension by the emitio
	// control plane and the individual agents to negotiate.
	Trigger              []byte   `protobuf:"bytes,1,opt,name=trigger,proto3" json:"trigger,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EmitTrigger) Reset()         { *m = EmitTrigger{} }
func (m *EmitTrigger) String() string { return proto.CompactTextString(m) }
func (*EmitTrigger) ProtoMessage()    {}
func (*EmitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_emitio_65d291393ec10fad, []int{5}
}
func (m *EmitTrigger) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EmitTrigger.Unmarshal(m, b)
}
func (m *EmitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EmitTrigger.Marshal(b, m, deterministic)
}
func (dst *EmitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmitTrigger.Merge(dst, src)
}
func (m *EmitTrigger) XXX_Size() int {
	return xxx_messageInfo_EmitTrigger.Size(m)
}
func (m *EmitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_EmitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_EmitTrigger proto.InternalMessageInfo

func (m *EmitTrigger) GetTrigger() []byte {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func init() {
	proto.RegisterType((*EmitHeader)(nil), "EmitHeader")
	proto.RegisterType((*EmitMeta)(nil), "EmitMeta")
	proto.RegisterMapType((map[string]string)(nil), "EmitMeta.MetaEntry")
	proto.RegisterType((*EmitBody)(nil), "EmitBody")
	proto.RegisterType((*EmitInput)(nil), "EmitInput")
	proto.RegisterType((*EmitOutput)(nil), "EmitOutput")
	proto.RegisterType((*EmitTrigger)(nil), "EmitTrigger")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EmitIOClient is the client API for EmitIO service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EmitIOClient interface {
	Emit(ctx context.Context, opts ...grpc.CallOption) (EmitIO_EmitClient, error)
}

type emitIOClient struct {
	cc *grpc.ClientConn
}

func NewEmitIOClient(cc *grpc.ClientConn) EmitIOClient {
	return &emitIOClient{cc}
}

func (c *emitIOClient) Emit(ctx context.Context, opts ...grpc.CallOption) (EmitIO_EmitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EmitIO_serviceDesc.Streams[0], "/EmitIO/Emit", opts...)
	if err != nil {
		return nil, err
	}
	x := &emitIOEmitClient{stream}
	return x, nil
}

type EmitIO_EmitClient interface {
	Send(*EmitInput) error
	Recv() (*EmitOutput, error)
	grpc.ClientStream
}

type emitIOEmitClient struct {
	grpc.ClientStream
}

func (x *emitIOEmitClient) Send(m *EmitInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *emitIOEmitClient) Recv() (*EmitOutput, error) {
	m := new(EmitOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EmitIO service

type EmitIOServer interface {
	Emit(EmitIO_EmitServer) error
}

func RegisterEmitIOServer(s *grpc.Server, srv EmitIOServer) {
	s.RegisterService(&_EmitIO_serviceDesc, srv)
}

func _EmitIO_Emit_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EmitIOServer).Emit(&emitIOEmitServer{stream})
}

type EmitIO_EmitServer interface {
	Send(*EmitOutput) error
	Recv() (*EmitInput, error)
	grpc.ServerStream
}

type emitIOEmitServer struct {
	grpc.ServerStream
}

func (x *emitIOEmitServer) Send(m *EmitOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *emitIOEmitServer) Recv() (*EmitInput, error) {
	m := new(EmitInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EmitIO_serviceDesc = grpc.ServiceDesc{
	ServiceName: "EmitIO",
	HandlerType: (*EmitIOServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Emit",
			Handler:       _EmitIO_Emit_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "emitio.proto",
}

func init() { proto.RegisterFile("emitio.proto", fileDescriptor_emitio_65d291393ec10fad) }

var fileDescriptor_emitio_65d291393ec10fad = []byte{
	// 316 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x51, 0x41, 0x6b, 0xb3, 0x40,
	0x10, 0x75, 0x93, 0x7c, 0x26, 0x8e, 0x1e, 0x3e, 0xb6, 0x3d, 0x48, 0x0e, 0x6d, 0x58, 0x08, 0xf1,
	0x64, 0x4b, 0x7a, 0x68, 0x29, 0xbd, 0x34, 0x10, 0xb0, 0x87, 0x12, 0x90, 0xfe, 0x01, 0xd3, 0x2c,
	0xa9, 0x34, 0xba, 0xa2, 0x6b, 0xc1, 0x4b, 0x7f, 0x7b, 0x99, 0x59, 0xdd, 0xa6, 0x17, 0x99, 0x99,
	0xf7, 0x9e, 0xef, 0x3d, 0x85, 0x40, 0x16, 0xb9, 0xce, 0x55, 0x5c, 0xd5, 0x4a, 0x2b, 0xf1, 0x04,
	0xb0, 0x2d, 0x72, 0x9d, 0xc8, 0xec, 0x20, 0x6b, 0xce, 0x61, 0x52, 0x66, 0x85, 0x0c, 0xd9, 0x82,
	0x45, 0x5e, 0x4a, 0x33, 0x9f, 0xc3, 0xac, 0xaa, 0x65, 0x23, 0xcb, 0x77, 0x19, 0x8e, 0xe8, 0x6e,
	0x77, 0x71, 0x82, 0x19, 0xaa, 0x5f, 0xa5, 0xce, 0xf8, 0x0a, 0x26, 0x85, 0xd4, 0x59, 0xc8, 0x16,
	0xe3, 0xc8, 0x5f, 0x5f, 0xc4, 0x03, 0x10, 0xe3, 0x63, 0x5b, 0xea, 0xba, 0x4b, 0x89, 0x30, 0xbf,
	0x07, 0xcf, 0x9e, 0xf8, 0x7f, 0x18, 0x7f, 0xca, 0xae, 0x37, 0xc4, 0x91, 0x5f, 0xc2, 0xbf, 0xaf,
	0xec, 0xd4, 0x0e, 0x66, 0x66, 0x79, 0x1c, 0x3d, 0x30, 0x71, 0x65, 0xdc, 0x36, 0xea, 0xd0, 0x61,
	0xd2, 0xbd, 0x3a, 0x18, 0x61, 0x90, 0xd2, 0x2c, 0xbe, 0xc1, 0x43, 0xfc, 0xa5, 0xac, 0x5a, 0xcd,
	0x97, 0xe0, 0x7e, 0x50, 0x29, 0xa2, 0xf8, 0x6b, 0x3f, 0xfe, 0xed, 0x99, 0x38, 0x69, 0x0f, 0xf2,
	0xeb, 0x3e, 0xf5, 0x88, 0x48, 0x9e, 0x4d, 0x9d, 0x38, 0x26, 0x2d, 0x12, 0xc8, 0x68, 0x7c, 0x46,
	0xc0, 0x04, 0x48, 0x40, 0x60, 0x33, 0x03, 0x37, 0x47, 0xc7, 0x46, 0x3c, 0x9b, 0x6f, 0xb9, 0x6b,
	0x35, 0x06, 0x88, 0x60, 0xaa, 0xeb, 0xfc, 0x78, 0xb4, 0x09, 0x02, 0xd2, 0xbe, 0x99, 0x5b, 0xe2,
	0xa4, 0x03, 0xbc, 0xf1, 0x60, 0xaa, 0x48, 0xd3, 0x88, 0x15, 0xf8, 0x67, 0x24, 0x1e, 0xfe, 0x7d,
	0x47, 0x60, 0x35, 0xeb, 0x1b, 0x70, 0xa9, 0xeb, 0x8e, 0x2f, 0x61, 0x82, 0x13, 0x87, 0xd8, 0x96,
	0x9f, 0x9b, 0xb2, 0x26, 0x88, 0x70, 0x22, 0x76, 0xcb, 0xf6, 0x2e, 0xfd, 0xef, 0xbb, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xe5, 0x78, 0xce, 0x17, 0xff, 0x01, 0x00, 0x00,
}
